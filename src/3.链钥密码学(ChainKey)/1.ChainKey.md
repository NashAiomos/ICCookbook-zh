

# 链钥密码学（Chain-key cryptography）

IC的共识协议确实使用了区块链，但它也采用了公钥加密技术，特别是电子签名：NNS维护的注册表用于将公钥绑定至节点副本及子网形成一个整体。这实现了一个独一无二的强大技术集合，我们称之为**链钥密码学**，它有几个组成部分。



# 阈值签名

链钥密码学的第一个组成部分是阈值签名：阈值签名是一个成熟的加密技术，它允许子网拥有一个公共的验证签名密钥，对应的签名私钥分成片段分配给子网中的节点副本，而分配保证作恶节点无法伪造任何签名，而诚实节点拥有的私钥片段可以允许子网生成符合IC原则和协议的签名。

这些阈值签名的一个关键应用在于一个子网的单独输出可以由另一个子网或是外部用户进行验证，验证可以简单地利用该子网（第一个子网）的公共验证签名密钥来验证电子签名实现。

需要注意的是，子网的公共验证签名密钥可以从NNS中获取—该公共验证签名密钥在子网的生命周期中保持不变（即使子网的成员在该生命周期中可能发生变化）。这与许多不可扩展的区块链协议形成鲜明的对比，其需要验证整个区块链来验证单个输出。



## BLS阈值签名

### 秘密共享

### 拉格朗日插值



正如我们所看到的，这些阈值签名在IC中还有许多其他应用。一个应用于让子网中的每个节点副本可以访问无法预测的伪随机数位（衍生于此类阈值签名）。这是共识层使用的随机信标和执行层使用的随机磁带的基础。

为了安全地部署阈值签名，IC采用了创新性的分布式密钥生成（以下简称DKG）协议，来构建公共签名验证密钥，并为每个节点副本提供对应签名私钥的一个片段，用于我们的故障和通信模型。



链钥密码学也包括一系列复杂的技术，用于随时间推移健壮和安全地维护基于区块链的复制状态机，合起来我们称之为链演进技术。每个子网在包含多轮（通常大约是几百轮）的时期（Epoch）内运行。利用阈值签名和其他一些技术，链演技术实现了许多按时期定期执行的基本维护工作：

**垃圾回收**：在每一时期的末尾，所有已经被处理的输入以及所有排序这些输入所需要的共识层消息，可以安全地从每个节点副本的内存中清除。这对防止对于节点副本的存储需求的无限增长至关重要。这也与许多不可扩展的区块链协议形成对比，它们必须存储从创世区块开始的整个区块链。

**快速转发**：如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。这也与许多不可扩展的区块链协议形成对比，它们必须处理从创世区块开始的整个区块链。

**子网成员变更**：子网的成员（由NNS决定，详见章节1.5）可能会随着时间变化。这仅可能发生在时期的边缘，需要小心操作以确保一致且正确的行为。

**主动秘密再共享**：我们在上面的章节1.6.1中提到 IC 是如何使用链钥密码学——具体来说，阈值签名——来进行输出验证。它基于的就是**秘密共享**，通过将一个秘密（在这里就是签名私钥）拆分成片段分别存储在节点副本中，从而避免了任何单点故障。在每个时期开始时，这些片段都会被**主动再共享**。这实现了两个目标：

* 当一个子网的成员发生变动时，再共享可以确保任何新成员都有相应的秘密片段，而任何不再是成员的节点副本就不再会拥有秘密片段。

* 如果在任意一个时期，甚至每个时期都有少量的秘密片段被泄露给攻击者，这些片段也不会帮助到攻击者。

**协议升级**：如果IC协议本身需要升级，修复漏洞或是增加新功能，可以在时期开始时通过特殊协议自动完成。







# 链钥密码学I：阈值签名

IC的链钥密码学的一个关键组成部分是阈值签名方案[[Des87]](#Des87)。IC在多处应用了阈值签名。假设子网中的节点副本数量为$n$，故障节点数量上限为$f$。

- 共识层使用$(f+1)/n$的阈值签名来实现随机信标（详见[章节5.5](#5.5 随机信标 )）。
- 执行层使用$(f+1)/n$的阈值签名来实现随机磁带，用于向容器提供不可预测的伪随机数（详见[章节7.1](#7.1 随机磁带)）。
- 执行层使用$(n-f)/n$的阈值签名来认证复制状态。这既用于验证子网的输出（详见[章节6.1](#6.1 每轮认证状态)），也用于实现IC链演进技术中的快速转发功能。（详见[章节8.2](#8.2 CUPs)）

对于前两个应用（随机信标和随机磁带），阈值签名必须是唯一的，即给定公钥和消息，仅有一个有效签名。因为我们使用签名作为随机数生成器的种子，所有计算该阈值签名的节点副本必须对相同的种子达成共识。

## BLS阈值签名

我们基于BLS签名方案实现了阈值签名[[BLS01]](#BLS01)，使得调整阈值设定十分简单。

普通的BLS签名方案（即非阈值）利用两个质数阶均为$q$的群$\mathbb{G}$和$\mathbb{G}'$。我们假设$\mathbb{G}$通过基准点$g\in\mathbb{G}$生成，$\mathbb{G}'$通过基准点$g'\in\mathbb{G}'$生成。我们同样假设一个哈希函数$H_{\mathbb{G}'}$可以将其输入映射到$\mathbb{G}'$（一个随机预言机模型）。签名私钥元素$x\in\mathbb{Z}_q$，公共验证密钥$V$:= $g^x\in\mathbb{G}$。

非阈值的设定下，为对消息$m$签名，签名人计算$h'\leftarrow H_{\mathbb{G}'}(m)\in\mathbb{G'}$，然后计算签名$\sigma$:= $($h$')^x\in\mathbb{G}$。为验证签名是否有效，必须检验$log_{$h$'}\sigma$是否等于$log_gV$。为了高效地执行检验，BLS方案在群$\mathbb{G}$和$\mathbb{G}'$上使用了**配对**的概念，这是一种特殊的代数工具，当$\mathbb{G}$和$\mathbb{G}'$是特殊类型的**椭圆曲线**时可用。我们无法在这里详细介绍配对和椭圆曲线。更多细节详见[[BLS01]](#BLS01)。BLS签名具有签名唯一这一良好的特性（如上所述）。

在$t/n$的阈值设定下，我们有$n$个节点副本，其中任意$t$个都可以用于生成消息的签名。更具体来看，每个节点副本$P_j$私下持有签名密钥$x\in\mathbb{Z}_q$的一个片段$x_j\in\mathbb{Z}_q$，而群元素$V_j$:=$g^{x_j}$公开可用。密钥片段$(x_1,...,x_n)$是$x$的$t/n$秘密共享（详见[章节3.4](#3.4 PVSS方案)）。

给定消息$m$，节点副本$p_j$可以生成**签名片段**
$$
\sigma_j=(h')^{x_j}\in\mathbb{G}'
$$
与之前一样，$h':=H_{\mathbb{G}'}(m)$。为了验证这样的签名片段是否有效，必须检验$log_{h'}\sigma_j$是否等于$log_gV_j$。如上所述，这可以通过配对来完成—事实上，这和用公钥$V_j$验证普通BLS签名有效性完全一样。

这一阈值签名方案满足如下的**重构特性：**

给定消息$m$的任意$t$个有效签名片段$\sigma_j$的集合（由不同的节点副本提供），我们可以高效得计算出公共验证密钥下，消息m的有效BLS签名$\sigma$。

事实上，$\sigma$可以按如下公式计算

$$
\displaystyle \sigma\leftarrow\prod_{j}\sigma^{\lambda_j}_j\tag{1}
$$
*其中，$\lambda_j$可由签名该消息m的t个节点副本的索引，高效地计算出来。*

在$\mathbb{G}$的合理难度假设下，将$H_{\mathbb{G}'}$建模成随机预言机，这一方案可以满足如下的**安全性**：

假设最多有$f$个节点副本被敌对方破坏。它也无法计算出消息的有效签名，除非他获取了至少$t-f$个诚实节点副本对该消息的签名片段。



## 分布式密钥分发

为了实现BLS阈值签名，我们需要一种分发签名私钥给节点副本的方法。一种实现方法是让一个**可信方**直接计算所有这些私钥片段并分发给所有的节点副本。不幸的是，这可能会造成单点故障。相反，我们使用了**分布式密钥生成（以下简称DKG）协议**，它本质上允许节点副本在安全的分布式协议下，执行此类可信方的逻辑。

我们概述了当前实现的协议的顶层思想。推荐读者阅读[[Gro21]](#Gro21)了解更多细节。我们使用的DKG本质上是非交互式的。它有两个基本组成部分：

- **公开可验证秘密共享（以下简称PVSS）**方案，和
- **共识**协议。

尽管任何共识协议都适用，但毫无疑问我们使用了[第5章](#5 共识层)（也可见[第八章](#8 链钥密码学Ⅱ：链演进技术)）中的协议。

## 假设

所做的基本假设和[第一章](#1 引言)中所概述的一致：

- 异步通信，和
- $f<n/3$。

我们仅仅（在[章节5.1](#5.1 假设)中）间接地使用了*部分*同步假设，来确保共识协议的活性。

对于一个t/n的阈值签名方案，我们还假设

$$
f<t\leq n-f
$$
这（除了其他方面外）确保了（1）故障节点副本们无法独立地签名，和（2）诚实的节点副本们可以独立地签名。

我们还假设每个节点副本和一些公钥相关联，其中每个节点持有这些公钥的对应私钥。一个公钥是签名密钥（同[章节5.4](#5.4 公钥)中一样）。另一个公钥是公共加密密钥，用于实现PVSS方案的特殊公钥加密方案（详细方案如下）。



## PVSS方案

如上所述，假设$\mathbb{G}$通过基准点$g\in\mathbb{G}$生成的质数阶为q的群。假设$s\in\mathbb{Z}_q$是私钥。回想一下，阈值结构为$t/n$下，密钥s的Shamir密钥共享是向量$(s_1,...,s_n)\in\mathbb{Z}_q^n$，其中

$$
s_j:=a(j)\ \ (j=1,...,n)
$$
而

$$
a(x):=a_0+a_1x+...+a_{t-1}x^{t-1}\in\mathbb{Z}_q[x]
$$
是次数小于$t$的多项式，其中$a_0:=s$。该类密钥共享方案的关键属性是

- 根据$t$个$s_j$的集合，我们可以（多项式插值）有效地计算密钥$s=a_0=a(0)$，和
- 如果从$\mathbb{Z}_q$中一致且独立得抽取$a_1,...,a_{t-1}$，任意少于$t$个元素的集合都无法披露密钥$s$的任何信息。

&emsp;&emsp;在更高层面上，PVSS方案允许节点副本$P_i$，在此称为**dealer**，进行密钥共享并计算称为**dealing**的对象，其中包括

- 群元素向量$(A_0,...,A_{t-1})$，其中$A_k:=g^{a_k}$对于$k=0,...,t-1$，
- 密文向量$(c_1,...,c_n)$，其中$c_j$是$P_j$的公共验证密钥下对$s_j$的加密，
- 非交互式的零知识证明$\pi$，证明每个节点副本$c_j$确实加密了密钥片段—更准确地说，每个密文$c_j$解密的值$s_j$满足

$$
\displaystyle g^{s_j}=\prod^{t-1}_{k=0}A_k^{j^k}=g^{a(j)}\tag{2}
$$

我们注意到，为了确保DKG协议的整体安全性，PVSS方案必须提供适当级别的所选密文安全性。具体来说，dealer必须将其身份作为关联数据嵌入dealing，并且加密的共享片段必须要保持隐匿，即使是在选择密文攻击中，敌对方可以用与创建dealing无关的关联数据，解密任意dealing。

如果不考虑效率问题，实现PVSS方案很容易。方案中利用类似ElGamal的加密方案，对每个$s_j$逐位加密，然后对公式[（2）](#GS2)使用标准的非交互式零知识证明，该证明基于对相应的Sigma协议(详见[[CDS94])](#CDS94)应用标准的Fiat-Shamir转换(详见[[FS86])](#FS86)实现。尽管这产生了一个多项式时间的方案，但是并不实用。然而，有很多可能的方法来优化这个类型的方案。关于IC中使用的高度优化的PVSS方案，详见[[Gro21]](#Gro21)。



## 基础DKG协议

使用PVSS方案和共识协议，基础的DKG协议十分简单。

1. 每个节点副本向其他节点副本广播关于随机密钥的**已签名dealing**。

  这样的已签名dealing包括一个dealing主体，dealer身份以及dealer公钥下对该dealing的签名。

  如果语法格式正确，签名和非交互式的零知识证明有效，那么这样的签名dealing是有效的。

2. 利用共识协议，节点副本对$f+1$的有效的已签名dealing集合$S$达成共识。

3. 假设集合$S$中的第$i$个dealing包含群元素向量$(A_{i,0},...,A_{i,t-1})$和密文向量$(c_{i,1},...,c_{i,n})$。

&emsp;&emsp;然后阈值签名方案的公共验证密钥是

$$
\displaystyle V:=\prod_iA_{i,0}
$$
注意，签名私钥被隐式定义

$$
x:=log_gV
$$
副本$P_j$的签名私钥x的片段为

$$
\displaystyle x_j:=\sum_i s_{i,j}
$$
其中$s_{i,j}$是$p_j$的解密私钥下对$c_{i,j}$的解密。

副本$P_j$的公共验证密钥是

$$
\displaystyle V_j:=\prod_i \prod^{t-1}_{k=0}A_{i,k}^{j^k}=g^{x_j}
$$
需要注意的是，密钥片段$x_j$包含$x$的阈值结构为$t/n$的Shami密钥共享。因此，公式[（1）](#GS1)中出现的只是拉格朗日插值系数。这证实了[章节3.1](#3.1 BLS阈值签名)中提到的*重构特性*。至于中[章节3.1](#BLS阈值签名)提及的安全性，可被如下证明，在$H_{\mathbb{G}'}$建模成随机预言机的情况下，假设PVSS方案是安全的，群$\mathbb{G}$和$\mathbb{G}'$（通过配对）满足**one-more Diffie-Hellman**的特定类型的难度假设，即不存在有效的对手方，有概率赢得下面的博弈：

挑战者随机选择$\mu_1,...,\mu_k\in\mathbb{Z}_q$和$v_1,...,v_l\in\mathbb{Z}_q$，将给到对手方$\{g^{\mu_i}\}^k_{i=1}$和$\{(g')^{v_j}\}^l_{j=1}$ 

对手方向挑战者发起一系列查询请求，每一个请求都是$\{k_{i,j}\}_{i,j}$形式的向量，挑战者回应对应的

$$
\displaystyle \prod_{i,j}((g')^{\mu_iv_i})^{k_{i,j}}
$$
为结束这场博弈，对手方输出向量$\{\lambda_{i,j}\}_{i,j}$和群元素$h'\in\mathbb{G}'$，并将赢得博弈如果

$$
h'\displaystyle =\prod_{i,j}((g')^{\mu_iv_i})^{\lambda_{i,j}}
$$
并且输出向量$\{\lambda_{i,j}\}_{i,j}$不是请求向量的线性组合。

尽管当$t>f+1$的情况下，需要这类one-more Diffie-Hellman假设，但是当$t=f+1$的情况下，可以采用较弱的假设(即所谓的co-CDH假设，普通BLS签名方案的安全性即基于此)。



## 再共享协议

基础DKG协议可以被很容易地修改，因此不需要创建一个新的随机密钥$x$的共享，而是创建一个先前共享密钥的新随机共享。

- 修改基础协议的第1步，以便每个节点可以广播已有共享片段的已签名dealing
- 修改第2步，以便就$t$个有效的已签名dealing集合达成共识。此外，每个dealing都经验证以确保是现有共享片段的dealing（这意味着在第$i$个dealing中$A_{i,0}$的值应当等于$V_i$的旧值）。
- 第3步中，通过计算$i$个拉格朗日插值系数的和（和乘积），等于新的$x_j$（和$V_j$）。





# 链钥密码学Ⅱ：链演进技术

如[章节1.6.2](#1.6.2 链演进技术（Chain-evolution technology）)所述，链钥密码学包括一系列复杂的技术，用于健壮和安全地持续维护基于区块链的复制状态机，合起来我们称之为**链演进技术**。每个子网在包含多轮（通常大约是几百轮）的**时期**（Epoch）内运行。链演技术实现了许多按时期定期执行的基本维护工作：*垃圾回收，快速转发，子网成员变更，主动秘密再共享和协议升级。*

链演进技术包含两个基本组成部分：**摘要块（Summary Bblocks）**和**追赶包（Catch-Up Packages，以下简称CUPs）**。

## 摘要块

每个时期的第一个区块是**摘要块**。摘要块包含特殊数据，用于管理不同阈值签名方案的密钥片段（详见[第3章](#3 链钥密码学I：阈值签名)）。其中有两种阈值签名方案：

- 阈值结构为$(f+1)/n$的方案中，每个时期生成一个新的签名密钥；（三分之一）
- 阈值结构为$(n-f)/n$的方案中，每个时期重新共享一次签名密钥。（九分之七）

阈值低的方案用于*随机信标*和*随机磁带*，而阈值高的方案用于验证子网的复制状态。

回想一下，DKG协议（详见[章节3.5](#3.5 基础DKG协议)）要求，对于每个签名密钥，有一个dealing的集合，而每个副本可以根据这组dealing，非交互式得获取它的签名密钥片段。

再回想一下，除了别的之外，NNS还维护着决定子网成员的**注册表**（详见[章节1.5](#1.5 权限模型)）。注册表（以及子网成员）会随时间改变。因此，子网必须在不同时间出于不同目的，对使用的**注册表版本**达共识。这一信息也存储在摘要块中。

时期 $i$ 的摘要块包括如下数据字段。

- $currentRegistryVersion$。这个注册表版本将决定时期 $i$中的*共识委员会（consensus committee）*—所有共识层的任务（生成区块，公证，最终确认）都由这个委员会执行。

- *$nextRegistryVersion$。*在每一轮共识中，区块生成者会将其知道的最新注册表版本（不得早于提议的区块的构建时间）包含在区块提案内。这确保了时期$i$中的*nextRegistryVersion*是最新值。

    时期 $i$中的$currentRegistryVersion$值设置为时期$i-1$中的$nextRegistryVersion$值。

- $currentDealingSets$。这个dealing集用于决定时期$i$中签名消息的阈值签名密钥。

    正如我们所看到的，时期 $i$中的阈值签名委员会是时期$i-1$中的共识委员会。

- $nextDealingSets$。这个字段收集和存储时期$i-1$中*收集到*的dealing[^6]。时期 $i$中的$currentDealingSets$的值将被设置为时期$i-1$中$nextDealingSets$的值（本身包含时期$i-2$中收集到的dealing）。

- $collectDealingParams$。这个字段描述了时期$i$中需要*收集*的dealing集的参数。时期 $i$中，区块生成者会将经这些参数验证有效的dealing，放进提议的区块内。

    Dealings的*接受委员会*基于时期$i$的摘要块的$nextRegistryVersion$。

    对于低阈值的签名方案，时期$i$中的*交易委员会*是时期$i$中的共识委员会。

    对于高阈值的签名方案，密钥片段的共享是基于时期$i$中的$nextDealingSets$。因此时期$i$中的*交易委员会*是时期$i-1$中的*接受委员会*，也是时期$i$中的*共识委员会*。

    还要注意的是，时期$i$中的阈值签名委员会是时期$i-2$中的接受委员会，其是时期$i-1$中的共识委员会。

时期$i$中的共识协议依赖于时期 $i$中的$currentRegistryVersion$和$currentDealingSets$ —— 具体来说，

* 共识委员会本身基于*$currentRegistryVersion$*，

* 共识中的随机信标基于$currentDealingSets$。

此外，同其他区块一样，在时期$i$开始的时候可能会有多个经过公证的摘要块，并且这种歧义需要在时期$i$中经过共识来解决。这种看似循环的问题的解决办法是，保证时期$i-1$开始时的摘要块，在时期$ i$开始前已经被最终确认，因为新的摘要块的相关值，是直接从老的摘要块复制而来。这实际上是一个*隐含的同步假设*，但它更是一个学术假设。事实上，因为[章节5.12.2](#5.11.2 区块生成详述)中讨论的确保活性的“共识降速（consensus throttling）”，也因为时期的长度很长，下面的情况本质上不可能发生：早在共识进展到时期$i-1$结束之时，时期$i-1$的摘要块没有被最终确认，公证延迟函数将增长到非常之大，因此最终确认需要的部分同步假设（实际上）肯定会（基本）满足[^7]。

[^6]: 我们省略的一个细节是，如果在时期$i-1$中，我们没有收集到所有需要的交易，那么作为备选方案，时期$i$中的下一交易集的值将被设置为时期$i$中的$currentDealingSets$的值。如果这种情况发生，那么协议将酌情使用之前的交易委员会和阈值签名委员会。
[^7]: 另外需要注意的是，时期$i$中收集的交易取决于时期$i$的摘要块，具体来说，就是$nextDealingSets$和$nextRegistryVersion$。因此在时期$i$的摘要块被最终确定之前，这些交易不应当生成且不能被验证。



## Catch Up Packages

在阐述 CUP 之前，我们首先需要指出随机信标的一个细节：每一轮的随机信标取决于前一轮的随机信标。它不是 CUP 的基本特性，但是影响了 CUP 的设计。

**CUP**是一种特殊的（不在区块链上的）消息，它（基本上）拥有一个节点副本在不知道先前时期任何信息下，在时期的起始点开始工作时所需的一切。它包含如下的数据字段：

- **整个**复制状态的默克尔哈希树的根（与[章节1.6](#1.6 链钥密码学（Chain-key cryptography）)中的每轮验证的部分状态不同）。
- 时期的摘要块。
- 时期第一轮的随机信标。
- 子网对上述字段的$(n-f)/n$的阈值签名。

为生成给定时期的CUP，节点副本必须等到该时期的摘要块已经被最终确认，并且对应的每轮状态经过验证。如前所述，*整个*复制状态必须经哈希函数处理为一个默克尔树—尽管有很多技术用于加快这一过程，这个成本代价仍然非常大，这也是为什么每个时期仅处理一次。因为CUP仅包含这个默克尔树的根，因此我们使用了一个**状态同步**子协议，允许节点副本从对等节点中提取它所需要的任何状态—同样地，我们用了很多技术来加快这一过程，它的成本代价仍然很大。因为我们对CUP使用了高阈值签名，因此可以保证在任何时期只有一个有效的CUP，而且可以从很多对等节点中提取状态。同时，阈值签名方案的公钥保持一致，CUP可以在不知道当前子网的参与节点的情况下验证。



## 链演进技术实现

**垃圾回收：**因为CUP包含特定时期的信息，因此每个节点副本可以安全地清除该时期前所有已处理的输入，以及对这些输入排序的共识层消息。

**快速转发：**如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。该节点副本可以通过获取最新CUP做到。利用从CUP中包含的摘要块和随机信标，以及来自其他节点副本的（还没有被清除的）共识消息，该节点副本可以从相应时期的起始点开始，向前运行共识协议。该节点也可以使用状态同步子协议来获取对应时期开始时的复制状态，这样它也可以开始处理共识层产生的输入。

图5描绘了快速转发。此处，我们假设需要一个需要追赶的节点副本处于时期起始点，（比方说）块高为101，有一个CUP。这个CUP包含了块高101的复制状态的默克尔树的根，块高101的摘要块（绿色标识）和块高101的随机信标。该节点会使用状态同步子协议，从它的对等节点中获取块高101的所有复制状态，并用CUP中的默克尔树来验证此状态。在获取到该状态后，节点副本可以参与到协议之中，从对等节点中获取块高102，103等等的区块（以及其他和共识相关的消息），并更新其复制状态的副本。如果其对等节点已经确认了更高高度的区块，该节点副本将尽快处理（以及公证和最终确认）这些从对等节点获取的已最终确认区块（以执行层所允许的最快速度）。

<img src="assets/1.ChainKey/图5：快速转发.png" alt="截屏2022-02-13 23.36.57" style="zoom:80%;" />

<center>图5：快速转发</center>

**子网成员变更：**我们已经讨论过特定时期内，如何使用摘要块来加密，使用哪个版本的注册表以及它如何决定子网成员，更具体来说，是各种任务的委员会成员。需要注意的是，即使一个节点副本从一个子网中移除，（如果可能的话）它应当额外履行一个时期的所分配到的委员会职责。

**主动秘密再共享：**我们已经讨论过了，如何使用摘要块生成和转发签名密钥。如有必要，需要的摘要块也可以从CUP中获取。

**协议升级：**CUP 也可用于协议升级。协议升级由 NNS 发起（详见[章节1.5](#1.5 权限模型)）。不考虑所有细节，基本细节如下：

- 当需要安装新版本的协议时，时期开始时的摘要块会做出指示；
- 所有运行老版本协议的节点副本，将继续运行共识协议直到最终确认摘要块并创建对应的CUP；然而，他们只会创建空区块，并不会将任何荷载传递给消息路由层和执行层；
- 安装新版本的协议后，运行新版本共识协议的节点副本，将从上述的CUP开始继续运行完整的协议。



