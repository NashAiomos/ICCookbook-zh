前端和后端都可以部署上链。客户端能直接通过 http 访问 IC 的智能合约。无限扩容。超高TPS。链上存储空间。非常低的 Gas 费。反向 Gas 费。


# 概述

什么是 IC 和 ICP ？

IC 的全称是互联网计算机（Internet Computer）；ICP 是互联网计算机协议（Internet Computer Protocol）。

IC 是专门为高速去中心化应用设计的通用网络计算平台。

互联网计算机（Internet Computer）由互联网计算机协议（Internet Computer Protocol）提供支持，其实用代币 ICP 代币的名称也由此而来。IC 协议的核心部分，核心IC协议，是一个 4 层协议，运行在各个子网的节点上。



通过运行核心 IC 协议，一个子网的节点实现了一个基于区块链的*复制状态机*，该状态机独立于其他子网取得进展（但与它们异步通信）。许多同时运行的子网的这种架构使 IC 几乎可以不受限制地扩展。



子网处理消息，这些消息由用户提交或来自其他子网。



智能合约是一种新的软件形式，它将彻底改变软件的编写方式、IT 系统的维护方式，以及应用程序及整体业务的构建方式。智能合约是在去中心化区块链上运行的可组合且自治的软件部件，这使得它们无法被篡改和停止。



在本文中，我们将介绍互联网计算机(以下简称IC)，作为一种全新的区块链设计，IC摆脱了智能合约在传统区块链上的速度、存储成本和计算能力方面的限制，使智能合约的全部潜力得以释放。IC允许智能合约第一次实现完全的去中心化，使得前端到后端都能被托管在区块链上。

IC 由一组加密协议组成，这些协议将独立运行的节点相互连接以组成一个区块链的集合。这些区块链托管并执行"容器(Canister)"，即 IC上的智能合约。容器可以存储数据，对数据进行通用计算，并提供完整的技术栈，从而直接为终端用户提供网络服务。

计算和存储开销采用“反向GAS模型”，这里需要容器开发人员将IC 的原生代币ICP兑换成cycles进行预付。ICP代币同时也用于治理：IC由去中心化自治组织（以下简称DAO）进行管理，DAO决定变更IC的网络拓扑结构和升级IC协议。



![Image](assets/1.了解IC/gc5YGvUU_400x400.jpg)



# 架构

IC 由一堆**子网** ( Subnet ) 组成，没有母网、主链、侧链、信标链这种概念，子网之间是平等的。共识由子网内部的节点们达成。子网的出块速度为一秒一个区块，且不同的子网同步并行出块。

**数据中心**通过 IC 的节点软件虚拟化为一堆**节点**，再用随机算法选取一些节点组成一个**子网**。所以一个子网里由多个数据中心的节点组成。

<img src="assets/1.了解IC/1.png" alt="image-20220515160844691" style="zoom: 20%;" />

子网数量也不固定，而是随着网络的资源使用情况动态地增加、合并。某个节点加入哪个子网、某个子网由哪些节点组成、选几个节点创建新子网、把一个子网拆分成 2 个子网，都由 NNS 决定。所以 IC 可以无限扩容，在世界各地新增子网。数据中心想要加入 IC 网络，需要获得 NNS 的投票许可，这种投票一般都是在要扩容时进行

>   在那些数据中心的 Canister 里消耗的 cycles 和这个数据中心获得的 ICP 的数量是动态平衡的。奖励多少 ICP 是根据数据中心对 IC 网络做出的贡献决定的，在数据中心部署的 Canister 越多提供算力、储存数据就越多，奖励的 ICP 也多。



# Chain Key

互联网计算机协议使用高级加密机制工具箱，统称为*链密钥加密*，它允许 IC 实现其他区块链无法实现的功能和可扩展性。

链密钥密码术的一个关键组成部分是*阈值签名方案*，它类似于普通的数字签名方案，不同之处在于秘密签名密钥分布在子网中的所有副本中，这样密钥就不会被泄露窃取子网中的一个（甚至很大一部分）副本。该技术有很多好处，包括：

1. 任何人都可以通过简单地验证签名来验证从互联网计算机接收到的内容，而无需同步整个区块链。
2. IC的拓扑结构可以自主演化——可以添加新的节点和子网，可以恢复故障节点，可以自主升级协议。
3. 罐的不可预测和无偏伪随机数的来源。容器可以安全地运行需要随机性的算法。





链锁密码学技术 （ Chain Key ）通过聚合签名，让子网节点产生一个唯一的公钥签名 ( 子网 key / Subnet Key ) 。这是 IC 无限扩展性能的基础技术。

每个子网可以看成是一个独立的 “ 小区块链 ” ，子网之间靠 Chain Key 通信。因为已经在子网内部达成共识了，所以只要通过 Chain Key 验证就行了。



每个子网根据 **root key** 生成自己的**子网公钥** ( 子网 key / Subnet Key ) ，子网之间通信依靠子网公钥验证数据的真实性，所以不用下载其他子网的旧区块数据，可以直接发请求过去。

>   子网 1 用自己的子网 key 对信息签名，然后发给子网 2 ，子网 2 收到信息后用子网 1 的 key 验证信息。
>
>   只要拿着某个子网 key ，就能随时随地验证这个子网上的信息是否正确。每个 key 只有 48 kb 。

root key 是公开的，客户端浏览器可以用 root key 验证消息是不是 IC 网络发过来的、有没有被篡改。

<img src="assets/1.了解IC/3.png" alt="3" style="zoom:20%;" />



# 共识

共识由子网内部的节点们达成。

共识的内容为：用户与 Canister 之间的通信、Canister 之间的通信 以及 这些通讯的顺序。不同节点收到信息的顺序可能不一样，但是处理信息的顺序必须相同。

<img src="assets/1.了解IC/640-163955866077519.webp" alt="图片" style="zoom:80%;" />

**共识目标** 

在不正常（恶意、掉线等情况）节点数小于总节点数的三分之一时，都能保证以下三个特性：
安全性：在某个时刻如果两个节点认为他们对区块链达成了共识，那么他们实际上他们所看到的区块链就应该是同样的；
活跃性：区块会持续增长，系统会持续处理新增信息；
有效性：区块链中所有的区块和区块中的信息都是有效的，比如所有信息都被其发送者正确签名了；



**共识组成部分**

1. 区块构造：构造候选区块
2. 公证：保证区块的有效性
3. 随机数灯塔：对随机性达成共识以加速
4. 敲定：确定共识达成的时间



**下面以一个 4 节点的子网为例，按照共识的四个组成部分来描述子网是如何达成共识的。**

### 一、区块构造

子网中的节点充当区块构造器，负责构造区块并通过向子网广播提议新区块。

在某个特定的区块高度，比如区块高度 30 ，区块构造器负责把所有可获得的有效信息打包到一个区块中，然后广播。

有效信息包括：用户与 canister 的通信、 canister 之间的通信以及这些通信的顺序。

![图片](assets/1.了解IC/640-163955865420617.webp)

### 二、公证

公证过程中，节点使用 BLS 门限签名(2f + 1)对区块进行公证，当三分之二的节点验证并签名一个区块时，这个区块就获得了公证。节点的私钥通过 DKG （分布式密钥生成）来产生。

BLS 门限签名算法可以将同一个信息的多个签名聚合为一个固定大小的签名。这意味着即使子网很大、公证节点很多，公证的大小也会很小。

某些节点提议的区块可能是无效的，所以每个区块都必须经过公证，公证这一步骤使得每一轮都至少有一个有效区块产出。

以一个由 4 个节点组成的子网为例，假设当前区块高度为 29，并且之前的区块都已被公证过。

当节点 1 收到一个新的区块时，节点 1 会验证此区块，如果区块有效，节点会给这个区块一个签名，这个签名叫做公证份额（ notarization share ），然后把这个签名发送给子网中的其他节点，以表明节点 1 认为这个区块是有效的。

当节点 1 收到了节点 3 和 节点 4 对区块 30 进行了公证份额， 那么几个公证份额就会合成一个公证，这时区块 30 就得到了公证（总共有 4 个节点）。

![图片](assets/1.了解IC/640-163955865156715.webp)

如果节点公证了一个有效的区块30 后，又有一个有效的区块出现，那么也可以继续公证。

因为不同的节点可能对不同的区块进行了打包，进而公证的区块也可能不一样，如果在一个区块高度只公证一个区块，那么就可能出现所有区块都没有获得足够的公证份额，而导致区块链在这一高度卡住。

这意味着在同一个区块高度，可能会有多个区块被公证，此时的区块链可能是下图这个样子：

![图片](assets/1.了解IC/640-163955864939113.webp)

### 三、随机数灯塔

公证过后，每个区块高度可能会出现多个区块，这增加了达成共识的难度。因此 ICC 共识协议就使用随机数灯塔来减少每一轮产生的公证区块数。

在每个区块高度，子网内都会有一个共享的随机数叫做随机数灯塔，随机数灯塔是可验证且不可预测的。

节点使用 BLS 签名（f+1）对上一轮的随机数灯塔签名，当二分之一的节点对一个随机数灯塔签名，那么就会产生一个新的随机数灯塔，这将为子网共识提供随机性。

![图片](assets/1.了解IC/640-163955864745511.webp)

**区块构造器排序**

有了随机数灯塔，子网就可以使用随机数灯塔来对节点排序，节点会优先公证排名靠前的节点打包的区块，并且当节点看到了已公证的区块后就不再公证其他区块，进而减少每轮产生的区块数。

比如可以使用第 29 轮公证的随机数灯塔来对第 30 轮公证的区块构造器来排序。比如顺序为：节点1、节点4、节点2、节点 3 。顺序是随机的，并且由随机数灯塔来提供随机性。

当进入新一轮的公证后，计时器开启。开始时，节点只会对 只有排第一的节点打包的区块进行公证。

比如在第 30 轮公证时，节点 1 收到了一个有效的区块，但这个区块是由节点 4（排名第二）的节点发起提议的，所以节点 1 暂时不会对这个区块签名而是继续等待。如果节点 1 收到自排名第一的区块构造器构造的区块，那么节点 1 就会对这个区块签名。

如果一段固定时间之后，节点1 还没有提供有效的区块，那么节点就会开始公证节点 4 （排名第二）打包的区块，依次类推。

在大多数情况下，每轮都只会有一个区块被公证，但在某些情况下还是会产生两个及以上的区块，区块链还没有完成共识，因此我们还需要一个最终确认共识的步骤，那就是敲定。

### 四、敲定

![图片](assets/1.了解IC/640-16395586326399.webp)

![图片](assets/1.了解IC/640-16395586288407.webp)

然后就可以剔除这个高度之前出现的分支：

![图片](assets/1.了解IC/640-16395586206955.webp)

 **总结**

![图片](assets/1.了解IC/640.webp)



# NNS

NNS 也是一种子网，也由一堆节点组成。只不过 NNS 可以管理其他子网，节点加入 IC 网络需要 NNS 给它们发许可证。



# Canister

## 简介

在子网上运行了一堆 Canisters （罐子、容器、智能合约）。Canister 有智能合约的功能，可以存储后端逻辑、各种数据、前端资源。

每个 Canister 都是一个 wasm 容器，所有可以编译为 wasm 字节码的语言理论上都可以写 IC 的智能合约：Rust C C++ JavaScript Java Python 等等。（ - 2022·5·15 - 现在motoko 和 rust 的 cdk 比较成熟，别的语言的 sdk 正在开发）因此，前后端都可以编译为 wasm 并上链。

ETH 是一台同步的状态更新机器，由交易触发智能合约，对状态进行共识；而 IC 是一台异步的消息处理机，Canister 同时进行消息的接收、计算、返回，对消息的处理顺序共识。容器间不共享状态，只会通过通讯来处理事务。

>   浏览器支持 wasm 才能打开 Dapp 。需要浏览器先加载一个 Service Woker 检查浏览器是否支持 wasm 、用 root key 验证前端的内容。

<img src="assets/1.了解IC/image-20220515165856011.png" alt="image-20220515165856011" style="zoom: 67%;" />

Canister 对外提供 2 种调用方法：**update call** 和 **query call** 。

**update call** ：增 删 改。会对内存数据进行修改。因为要改数据，所以得在子网里达成共识。因为要达成公识，所以处理消息是**单线程**的，不支持并发。（在子网里达成过共识的东西就安全了，别的子网可以直接访问，不用再达成一遍共识了。）

**query call** ：查。每次调用 query call 时，都对节点内当前数据进行一次快速查询。因为不修改数据，所以不用达成共识，可以**多线程**，支持并发处理。一个 Canister 能同时处理很多个 query 方法。

Canister 之间可以互相通信，但是数据是隔离的，不能保证原子性，



部署后，**前端 canister 的 id 加上域名 ic0.app 就是网址** https://zur5z-byaaa-aaaag-aaxeq-cai.ic0.app 





II 是一种身份认证机制，底层原理还是私钥、公钥那些的。
只是把私钥托管到一个加密的 canister 里，不用让用户自己保存私钥了。
用户只要用自己指纹签名就可以授权应用访问用户的身份。不同的应用对应不同的身份。
而且用户在 II 里保存的每个设备都是一个私钥，用户可以增加、删除设备，也就是用户可以增加删除私钥。所以假如用户手机丢了，相当于丢了一个私钥，只要用anchor在其他设备上登录就可以删除手机这个设备了。
所以不能搜 II 里的别的用户。

所以 II 干的一件事就是把用户不同的设备添加进来，通过 II 的 anchor 对应的 master key 绑定，这个 master key 是托管到 canister 上的，这样只要有一个设备能添加进来，就能更改 II 里保存的设备，用户就不用接触私钥了。这个 master key 可以理解为一个总的私钥，只要有设备绑定在这个总私钥上，就不用担心 II 身份丢失，如果都丢了，就只能靠助记词恢复了。

所以 II 就是一种身份认证机制，II 里没有保存用户信息，只有用户的一个 II 身份，用户相关信息都是由应用自己保存的。

canister 里存的是 anchor 和对应的 master key ，anchor 是从 10000 开始递增。

当一个 anchor 登录不同 dapp 时，身份是不一样的。至于这个身份对应的用户信息是什么：用户名之类的，II 不保存。
在一个 anchor 不同的设备上登录 dapp ，身份是一样的。







### 关于容器数据扩容

DFINITY 的优势在于大规模高性能的去中心化数据库存取，DFINITY 的程序以容器为单位运行，容器中会存储业务相关的数据库，且容器之间不会共享状态数据。而目前 DFINITY 容器存储上限是 4G ，如果一个业务容器的 4G 存满之后，容器就需要面临扩容的问题，该如何解决？

目前 DFINITY 能允许容器在存储与带宽等资源即将耗尽时，自动 Fork 出一个新容器进行扩容。新的容器中只保存了最近的状态数据，会丢弃历史。两个容器间依然通过异步调用来实现交互。

同时，在设计容器时，需要把各种级别的数据分开存放。举个例子，如果直接在 DFINITY 上建立一个钱包容器，交易记录的数据量会比用户地址的数据大很多。如果这时候把这两类数据放入一个容器，就会影响后续的扩容能力。

因此我们需要把对最终一致性要求相同的数据放在一起。比如在将钱包的余额与地址放在一起，而交易记录就可以通过分片存放在不同的容器中。从而实现系统的自动弹性扩容。



### 探索新的编程范式

显然想要在 DFINITY 保证安全性地实现复杂应用，我们需要探索新的范式。

最终一致性与确定性在传统互联网的分布式架构下有一些解决方案，这是值得我们借鉴的。DFINITY 上的智能合约需要关注的是数据的最终一致性，从写入和读取入手。

首先当我们需要很强安全性保证时，可能把整个所有的逻辑放在一个容器里面。主要在一个容器中，所有的交易都是原子性的，这里确保了事务与数据两个层面的一致性。但这种方式面临着扩容的噩梦，显然是偷懒的做法。

传统互联网其实关注的是数据库中数据的一致性，而在 DFINITY 中其实分为两个部分：一个是业务层面的，这部分是可以通过更新合约变化的，我们其实不太需要保证这里的原子性；而还有一部分是数据层面的，也就是进入正交持久性的数据，落盘的数据，这才是我们需要保证一致性与原子性的地方。

在 DFINITY 中有使用了名为 stable 的变量类型来定义落盘的数据，这其实类似于传统的数据库，目前也有多个团队在做 DFINITY 的数据库引擎，有了这个底层落盘数据的一致性与原子性，上层的业务的安全性就依靠数据来保证一致性。

如果是借鉴原来分布式事务的概念，我们有四种方式实现这个能力：

* tcc 两端事务提交，这是目前银行转账使用的机制，在交易发生时我们先直接更新数据库的 stable 的最终一致数据，等大家都确认清楚后，再去提交。
* saga 的事务处理机制，首先建立一个事务协调程序，当某个容器需要发起一次跨合约的调用时可以向事务协调程序申请一个 ID，并通过这个 ID 向事务的终结程序汇报，最后大家都提交成功后，再进行整体的提交。
* 使用事务观察者模式，对 stable 的状态进行包装，每当发生状态的更新操作时，观察者都去记录更新前后的两个值，如果发现某一个事务失败，观察者会就使用之前的值回滚操作。



### 原子性问题

一切即 actor ，DFINITY 使用的编程模型与传统区块链有一定差异，反而与传统互联网的 akka 类似。

DFINITY 中的智能合约（即容器）之间的交互也与以太坊不同，DFINITY 的智能合约内部是向存在一个唯一线程，但是容器之间的交互是通过发送异步消息进行，因此容器间可以进行异步操作。如果一个容器向另一个容器发送请求后，需要等待另一个容器的处理结果，才能进行下一步操作。

DFINITY 中存在很多个对等的子网，智能合约会随机的部署上子网。对于部署合约的开发者与使用合约的用户来说，他们并不知道这个合约运行在哪一个子网中，因为片间通讯是无感的。在同一个子网的两个容器的交互，与在不同子网上两个容器的交互，在延迟、安全性、复杂度上都没有差别，因此无法感知到子网之间的差别。这也是异步消息系统的好处。

这样 DFINITY 获得了近乎无限的扩容能力，大大提升了通用计算能力。但这也导致了合约间的交互失去了原子性，而在以太坊上利用原子性特点实现了很多独特的服务，比如 DeFi 的闪电贷清算机制。

在失去了原子性后，开发者面临着新的挑战，特别是在实现 DeFi 应用上，如果依然按照过去以太坊上的编程范式，这导致交易失败后状态无法恢复的问题。

比如，如果在 DFINITY 上实现了设计多个容器交互的复杂应用，比如一个借贷应用，需要与稳定币、借出代币、流动性凭证三个合约交互，三个合约都成功调用才能完成借贷。但如果强行在 DFINITY 实现以太坊范式的调用，如果其中两个合约成功，而最后一个调用没有响应，那么借贷交易会失败，并且前两个合约的状态却已经完成，就会卡住，而不会退回去。表现在用户这边，就是钱已经质押上去，代币已经扣走，却没法完成借贷，也没有收到退款。



DFINITY 底层为 actor 编程模型，容器（即智能合约）间互相调用是异步操作，需要互相等待，子网间的调用也是异步的；





# Internet Identity









## Wallet

Wallet 是允许存储和管理 Cycle 的专用智能合约（Canister）。

Cycle 用于支付 IC 的计算和资源消耗。

Cycle 可以通过 ICP 转换获得。

Wallet 要归属于某个身份。



## Principal

Principal 本质是一种标识符，可以用于标识身份和 Canister（未来可能还有其他）。

比如可以使用 Principal ID 标识一个身份，当你第一次使用 Dfinity Canister SDK 时，dfx 命令行工具会为你创建 default 开发者身份（和一对公钥私钥），default 这个开发者身份就是由 Principal ID 标识。

*注意，开发者身份还可用于派生 Account ID（类似于以太坊地址），以代表「身份」将 ICP 代币保存在 Ledger Canister 中。*

同样，Canister ID 也是一种 Principal。

所以当说起 Principal 时，它可能会同时代表某个身份或者某个 Canister，比如 Wallet Canister。



## Controller

Controller 是具有安装、升级、删除 Canister 权限的 Principal。

一般情况下，一个 Canister 的 Controller 可以指定为某个身份、或者某个身份对应的 Wallet Canister。

在 dfx 0.9 之后，默认「身份」是 Canister 的 Controller 了，Wallet Canister 不再是默认 Controller（相当于 dfx 指定了 --no-wallet）。





# ICP的经济模型

ICP 的全称是 Internet Computer Protocol ，中文意思为互联网计算机，旨在构建一个去中心化、永不宕机、用户所有权由代币与治理驱动的通用区块链。

ICP 的网络通过 Network Nervous System（NNS，网络神经系统）来治理，治理代币叫 ICP。另外还有一个代币叫 Cycles，Cycles 用于支付在 IC 网络上 canister 的存储数据、收发数据、计算费用，类似于以太坊的 Gas 费。

Cycles 是用来供 canister （智能合约）运行的费用。 ICP 只能单向燃烧成 Cycles ，没法再变回 ICP ，ICP 与 Cycles 的汇率根据 ICP 价格动态调整，永远保持稳定的兑换一定数量的 Cycles ；这样ICP就会越来越少，随着 IC 网络使用者不断增加，更多的人会购买 ICP 来运行智能合约， IC 网络的价值也会不断增加。

数据中心成为节点要买大量 ICP 当押金，如果数据中心做恶，就罚 ICP 。

当 IC 上的生态越来越繁荣，越来越多的企业、组织在 IC 上部署去中心化应用 Dapp 时，就需要把 ICP 燃烧成 Cycles 交部署应用的费用。

持有 ICP 代币的用户可以把 ICP 质押在 NNS 中，创建 neuron（神经元），然后进行投票，投票之后会收到 ICP 代币奖励，这是 ICP 的通胀机制之一；但 NNS 的作用是投票治理，并不是赚利息。

另外，NNS 会给数据中心提供者发送 ICP 代币奖励，这种另一种通胀机制。

目前 ICP 只有这两种通胀机制。

ICP 代币可以兑换成 Cycles 代币，二者的汇率是动态变化的，以保证 Cycles 价值相对稳定，防止造成客户使用费用大幅增长的情况，这一点比以太坊高明多了。

客户使用 ICP 网络需要用 Cycles 支付，这部分 Cycles 会被燃烧，所以这是 ICP 的通缩机制，目前是唯一的通缩机制。

以上是 ICP 的经济模型介绍。





https://github.com/dfinity/awesome-icp

https://github.com/motoko-unofficial/awesome-motoko
