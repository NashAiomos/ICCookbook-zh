早期以太坊社区中有实现 “ 世界计算机 ” 的想法，建立一个分布在世界各地的去中心化基础设施。

但是以太坊的架构有一些局限性，使得它执行交易的性能较低、ETH 涨价导致高 Gas 费、扩展性不佳等等。一种解决方法是在原来的基础上改进：把以太坊的共识由 PoW 转为 PoS（Casper）、构建分片链（Shard）或者侧链；另一种解决方法就是推倒重来：重新设计一种可以高速处理信息、大规模存储数据的架构。IC 为了实现 “ 世界计算机 ” 的想法，重新设计了区块链架构，研发了更高效的共识，并配套创新的密码学组合。解决了传统区块链架构中速度、效率和扩展的限制。



前端和后端都可以部署上链。客户端能直接通过 http 访问 IC 的智能合约。无限扩容。超高TPS。链上存储空间。非常低的 Gas 费。反向 Gas 费。



ICP 如何让 Web3 和元宇宙更好用，更中心化的？

一个长期被提到的问题：当大多数 Web3 项目至少涉及一些 Web2 基础设施，而这些应用程序又依赖于那些和密码朋克精神违背的中心化软硬件提供商时，它们是如何做到去中心化的？

Web3 的去中心化理念承诺消除用户对科技巨头和主导平台的依赖，同时赋予用户社区权力。实际上，大多数去中心化应用程序 (dApp) 和 DeFi 服务在 Amazon 或 Cloudflare 上运行前端接口。 NFT 通常只是与托管在中心化云上的数据相关的区块链上的哈希。以太坊和其他链背后的许多节点都由 AWS、Google Cloud 和 Microsoft Azure 等云提供商运营。

这主要是因为没有其他满足用户期望体验的选项。开发者更专注于交易速度和用户的可访问性，而区块链通常不能足够快地响应请求和足够有效地扩展，所以开发者难以构建和部署完全在链上运行的 dApp。

“几乎所有 dApp 都使用 Infura 或 Alchemy 来与区块链交互，”Signal 创始人 Moxie Marlinspike 最近写道， “事实上，即使你将像 MetaMask 这样的钱包连接到 dApp，并且 dApp 通过你的钱包与区块链交互，MetaMask 也只是在调用 Infura。”

然而可以完全在链上运行的可扩展 Web3 平台的创新已经诞生，这些服务不依赖于任何像前文中提到的中介，并且保证用户可以完全控制他们的身份和数据。



## 概述

什么是 IC 和 ICP ？

IC 的全称是互联网计算机（Internet Computer）；ICP 是互联网计算机协议（Internet Computer Protocol）。

IC 是专门为高速去中心化应用设计的通用网络计算平台。

互联网计算机（Internet Computer）由互联网计算机协议（Internet Computer Protocol）提供支持，其实用代币 ICP 代币的名称也由此而来。IC 协议的核心部分，核心IC协议，是一个 4 层协议，运行在各个子网的节点上。



通过运行核心 IC 协议，一个子网的节点实现了一个基于区块链的*复制状态机*，该状态机独立于其他子网取得进展（但与它们异步通信）。许多同时运行的子网的这种架构使 IC 几乎可以不受限制地扩展。



子网处理消息，这些消息由用户提交或来自其他子网。



智能合约是一种新的软件形式，它将彻底改变软件的编写方式、IT 系统的维护方式，以及应用程序及整体业务的构建方式。智能合约是在去中心化区块链上运行的可组合且自治的软件部件，这使得它们无法被篡改和停止。



在本文中，我们将介绍互联网计算机(以下简称IC)，作为一种全新的区块链设计，IC摆脱了智能合约在传统区块链上的速度、存储成本和计算能力方面的限制，使智能合约的全部潜力得以释放。IC允许智能合约第一次实现完全的去中心化，使得前端到后端都能被托管在区块链上。

IC 由一组加密协议组成，这些协议将独立运行的节点相互连接以组成一个区块链的集合。这些区块链托管并执行"容器(Canister)"，即 IC上的智能合约。容器可以存储数据，对数据进行通用计算，并提供完整的技术栈，从而直接为终端用户提供网络服务。

计算和存储开销采用“反向GAS模型”，这里需要容器开发人员将IC 的原生代币ICP兑换成cycles进行预付。ICP代币同时也用于治理：IC由去中心化自治组织（以下简称DAO）进行管理，DAO决定变更IC的网络拓扑结构和升级IC协议。



![Image](assets/1.了解IC/gc5YGvUU_400x400.jpg)



## 架构

IC 由一堆**子网** ( Subnet ) 组成，没有母网、主链、侧链、信标链这种概念，子网之间是平等的。共识由子网内部的节点们达成。子网的出块速度为一秒一个区块，且不同的子网同步并行出块。

**数据中心**通过 IC 的节点软件虚拟化为一堆**节点**，再用随机算法选取一些节点组成一个**子网**。所以一个子网里由多个数据中心的节点组成。

<img src="assets/1.了解IC/1.png" alt="image-20220515160844691" style="zoom: 20%;" />

子网数量也不固定，而是随着网络的资源使用情况动态地增加、合并。某个节点加入哪个子网、某个子网由哪些节点组成、选几个节点创建新子网、把一个子网拆分成 2 个子网，都由 NNS 决定。所以 IC 可以无限扩容，在世界各地新增子网。数据中心想要加入 IC 网络，需要获得 NNS 的投票许可，这种投票一般都是在要扩容时进行

>   在那些数据中心的 Canister 里消耗的 cycles 和这个数据中心获得的 ICP 的数量是动态平衡的。奖励多少 ICP 是根据数据中心对 IC 网络做出的贡献决定的，在数据中心部署的 Canister 越多提供算力、储存数据就越多，奖励的 ICP 也多。



## Chain Key

互联网计算机协议使用高级加密机制工具箱，统称为*链密钥加密*，它允许 IC 实现其他区块链无法实现的功能和可扩展性。

链密钥密码术的一个关键组成部分是*阈值签名方案*，它类似于普通的数字签名方案，不同之处在于秘密签名密钥分布在子网中的所有副本中，这样密钥就不会被泄露窃取子网中的一个（甚至很大一部分）副本。该技术有很多好处，包括：

1. 任何人都可以通过简单地验证签名来验证从互联网计算机接收到的内容，而无需同步整个区块链。
2. IC的拓扑结构可以自主演化——可以添加新的节点和子网，可以恢复故障节点，可以自主升级协议。
3. 罐的不可预测和无偏伪随机数的来源。容器可以安全地运行需要随机性的算法。





链锁密码学技术 （ Chain Key ）通过聚合签名，让子网节点产生一个唯一的公钥签名 ( 子网 key / Subnet Key ) 。这是 IC 无限扩展性能的基础技术。

每个子网可以看成是一个独立的 “ 小区块链 ” ，子网之间靠 Chain Key 通信。因为已经在子网内部达成共识了，所以只要通过 Chain Key 验证就行了。



每个子网根据 **root key** 生成自己的**子网公钥** ( 子网 key / Subnet Key ) ，子网之间通信依靠子网公钥验证数据的真实性，所以不用下载其他子网的旧区块数据，可以直接发请求过去。

>   子网 1 用自己的子网 key 对信息签名，然后发给子网 2 ，子网 2 收到信息后用子网 1 的 key 验证信息。
>
>   只要拿着某个子网 key ，就能随时随地验证这个子网上的信息是否正确。每个 key 只有 48 kb 。

root key 是公开的，客户端浏览器可以用 root key 验证消息是不是 IC 网络发过来的、有没有被篡改。

<img src="assets/1.了解IC/3.png" alt="3" style="zoom:20%;" />



## 共识

共识由子网内部的节点们达成。

### 三、随机数灯塔





## NNS

NNS 也是一种子网，也由一堆节点组成。只不过 NNS 可以管理其他子网，节点加入 IC 网络需要 NNS 给它们发许可证。



## Canister

### 简介

在子网上运行了一堆 Canisters （罐子、容器、智能合约）。Canister 有智能合约的功能，可以存储后端逻辑、各种数据、前端资源。

每个 Canister 都是一个 wasm 容器，所有可以编译为 wasm 字节码的语言理论上都可以写 IC 的智能合约：Rust C C++ JavaScript Java Python 等等。（ - 2022·5·15 - 现在motoko 和 rust 的 cdk 比较成熟，别的语言的 sdk 正在开发）因此，前后端都可以编译为 wasm 并上链。

ETH 是一台同步的状态更新机器，由交易触发智能合约，对状态进行共识；而 IC 是一台异步的消息处理机，Canister 同时进行消息的接收、计算、返回，对消息的处理顺序共识。容器间不共享状态，只会通过通讯来处理事务。

>   浏览器支持 wasm 才能打开 Dapp 。需要浏览器先加载一个 Service Woker 检查浏览器是否支持 wasm 、用 root key 验证前端的内容。

<img src="assets/1.了解IC/image-20220515165856011.png" alt="image-20220515165856011" style="zoom: 67%;" />

Canister 对外提供 2 种调用方法：**update call** 和 **query call** 。

**update call** ：增 删 改。会对内存数据进行修改。因为要改数据，所以得在子网里达成共识。因为要达成公识，所以处理消息是**单线程**的，不支持并发。（在子网里达成过共识的东西就安全了，别的子网可以直接访问，不用再达成一遍共识了。）

**query call** ：查。每次调用 query call 时，都对节点内当前数据进行一次快速查询。因为不修改数据，所以不用达成共识，可以**多线程**，支持并发处理。一个 Canister 能同时处理很多个 query 方法。

Canister 之间可以互相通信，但是数据是隔离的，不能保证原子性，



部署后，**前端 canister 的 id 加上域名 ic0.app 就是网址** https://zur5z-byaaa-aaaag-aaxeq-cai.ic0.app 





II 是一种身份认证机制，底层原理还是私钥、公钥那些的。
只是把私钥托管到一个加密的 canister 里，不用让用户自己保存私钥了。
用户只要用自己指纹签名就可以授权应用访问用户的身份。不同的应用对应不同的身份。
而且用户在 II 里保存的每个设备都是一个私钥，用户可以增加、删除设备，也就是用户可以增加删除私钥。所以假如用户手机丢了，相当于丢了一个私钥，只要用anchor在其他设备上登录就可以删除手机这个设备了。
所以不能搜 II 里的别的用户。

所以 II 干的一件事就是把用户不同的设备添加进来，通过 II 的 anchor 对应的 master key 绑定，这个 master key 是托管到 canister 上的，这样只要有一个设备能添加进来，就能更改 II 里保存的设备，用户就不用接触私钥了。这个 master key 可以理解为一个总的私钥，只要有设备绑定在这个总私钥上，就不用担心 II 身份丢失，如果都丢了，就只能靠助记词恢复了。

所以 II 就是一种身份认证机制，II 里没有保存用户信息，只有用户的一个 II 身份，用户相关信息都是由应用自己保存的。

canister 里存的是 anchor 和对应的 master key ，anchor 是从 10000 开始递增。

当一个 anchor 登录不同 dapp 时，身份是不一样的。至于这个身份对应的用户信息是什么：用户名之类的，II 不保存。
在一个 anchor 不同的设备上登录 dapp ，身份是一样的。







### 关于容器数据扩容

DFINITY 的优势在于大规模高性能的去中心化数据库存取，DFINITY 的程序以容器为单位运行，容器中会存储业务相关的数据库，且容器之间不会共享状态数据。而目前 DFINITY 容器存储上限是 4G ，如果一个业务容器的 4G 存满之后，容器就需要面临扩容的问题，该如何解决？

目前 DFINITY 能允许容器在存储与带宽等资源即将耗尽时，自动 Fork 出一个新容器进行扩容。新的容器中只保存了最近的状态数据，会丢弃历史。两个容器间依然通过异步调用来实现交互。

同时，在设计容器时，需要把各种级别的数据分开存放。举个例子，如果直接在 DFINITY 上建立一个钱包容器，交易记录的数据量会比用户地址的数据大很多。如果这时候把这两类数据放入一个容器，就会影响后续的扩容能力。

因此我们需要把对最终一致性要求相同的数据放在一起。比如在将钱包的余额与地址放在一起，而交易记录就可以通过分片存放在不同的容器中。从而实现系统的自动弹性扩容。



### 探索新的编程范式

显然想要在 DFINITY 保证安全性地实现复杂应用，我们需要探索新的范式。

最终一致性与确定性在传统互联网的分布式架构下有一些解决方案，这是值得我们借鉴的。DFINITY 上的智能合约需要关注的是数据的最终一致性，从写入和读取入手。

首先当我们需要很强安全性保证时，可能把整个所有的逻辑放在一个容器里面。主要在一个容器中，所有的交易都是原子性的，这里确保了事务与数据两个层面的一致性。但这种方式面临着扩容的噩梦，显然是偷懒的做法。

传统互联网其实关注的是数据库中数据的一致性，而在 DFINITY 中其实分为两个部分：一个是业务层面的，这部分是可以通过更新合约变化的，我们其实不太需要保证这里的原子性；而还有一部分是数据层面的，也就是进入正交持久性的数据，落盘的数据，这才是我们需要保证一致性与原子性的地方。

在 DFINITY 中有使用了名为 stable 的变量类型来定义落盘的数据，这其实类似于传统的数据库，目前也有多个团队在做 DFINITY 的数据库引擎，有了这个底层落盘数据的一致性与原子性，上层的业务的安全性就依靠数据来保证一致性。

如果是借鉴原来分布式事务的概念，我们有四种方式实现这个能力：

* tcc 两端事务提交，这是目前银行转账使用的机制，在交易发生时我们先直接更新数据库的 stable 的最终一致数据，等大家都确认清楚后，再去提交。
* saga 的事务处理机制，首先建立一个事务协调程序，当某个容器需要发起一次跨合约的调用时可以向事务协调程序申请一个 ID，并通过这个 ID 向事务的终结程序汇报，最后大家都提交成功后，再进行整体的提交。
* 使用事务观察者模式，对 stable 的状态进行包装，每当发生状态的更新操作时，观察者都去记录更新前后的两个值，如果发现某一个事务失败，观察者会就使用之前的值回滚操作。



### 原子性问题

一切即 actor ，DFINITY 使用的编程模型与传统区块链有一定差异，反而与传统互联网的 akka 类似。

DFINITY 中的智能合约（即容器）之间的交互也与以太坊不同，DFINITY 的智能合约内部是向存在一个唯一线程，但是容器之间的交互是通过发送异步消息进行，因此容器间可以进行异步操作。如果一个容器向另一个容器发送请求后，需要等待另一个容器的处理结果，才能进行下一步操作。

DFINITY 中存在很多个对等的子网，智能合约会随机的部署上子网。对于部署合约的开发者与使用合约的用户来说，他们并不知道这个合约运行在哪一个子网中，因为片间通讯是无感的。在同一个子网的两个容器的交互，与在不同子网上两个容器的交互，在延迟、安全性、复杂度上都没有差别，因此无法感知到子网之间的差别。这也是异步消息系统的好处。

这样 DFINITY 获得了近乎无限的扩容能力，大大提升了通用计算能力。但这也导致了合约间的交互失去了原子性，而在以太坊上利用原子性特点实现了很多独特的服务，比如 DeFi 的闪电贷清算机制。

在失去了原子性后，开发者面临着新的挑战，特别是在实现 DeFi 应用上，如果依然按照过去以太坊上的编程范式，这导致交易失败后状态无法恢复的问题。

比如，如果在 DFINITY 上实现了设计多个容器交互的复杂应用，比如一个借贷应用，需要与稳定币、借出代币、流动性凭证三个合约交互，三个合约都成功调用才能完成借贷。但如果强行在 DFINITY 实现以太坊范式的调用，如果其中两个合约成功，而最后一个调用没有响应，那么借贷交易会失败，并且前两个合约的状态却已经完成，就会卡住，而不会退回去。表现在用户这边，就是钱已经质押上去，代币已经扣走，却没法完成借贷，也没有收到退款。



DFINITY 底层为 actor 编程模型，容器（即智能合约）间互相调用是异步操作，需要互相等待，子网间的调用也是异步的；







### Wallet

Wallet 是允许存储和管理 Cycle 的专用智能合约（Canister）。

Cycle 用于支付 IC 的计算和资源消耗。

Cycle 可以通过 ICP 转换获得。

Wallet 要归属于某个身份。



### Principal

Principal 本质是一种标识符，可以用于标识身份和 Canister（未来可能还有其他）。

比如可以使用 Principal ID 标识一个身份，当你第一次使用 Dfinity Canister SDK 时，dfx 命令行工具会为你创建 default 开发者身份（和一对公钥私钥），default 这个开发者身份就是由 Principal ID 标识。

*注意，开发者身份还可用于派生 Account ID（类似于以太坊地址），以代表「身份」将 ICP 代币保存在 Ledger Canister 中。*

同样，Canister ID 也是一种 Principal。

所以当说起 Principal 时，它可能会同时代表某个身份或者某个 Canister，比如 Wallet Canister。



### Controller

Controller 是具有安装、升级、删除 Canister 权限的 Principal。

一般情况下，一个 Canister 的 Controller 可以指定为某个身份、或者某个身份对应的 Wallet Canister。

在 dfx 0.9 之后，默认「身份」是 Canister 的 Controller 了，Wallet Canister 不再是默认 Controller（相当于 dfx 指定了 --no-wallet）。





## ICP的经济模型

ICP 的全称是 Internet Computer Protocol ，中文意思为互联网计算机，旨在构建一个去中心化、永不宕机、用户所有权由代币与治理驱动的通用区块链。

ICP 的网络通过 Network Nervous System（NNS，网络神经系统）来治理，治理代币叫 ICP。另外还有一个代币叫 Cycles，Cycles 用于支付在 IC 网络上 canister 的存储数据、收发数据、计算费用，类似于以太坊的 Gas 费。

Cycles 是用来供 canister （智能合约）运行的费用。 ICP 只能单向燃烧成 Cycles ，没法再变回 ICP ，ICP 与 Cycles 的汇率根据 ICP 价格动态调整，永远保持稳定的兑换一定数量的 Cycles ；这样ICP就会越来越少，随着 IC 网络使用者不断增加，更多的人会购买 ICP 来运行智能合约， IC 网络的价值也会不断增加。

数据中心成为节点要买大量 ICP 当押金，如果数据中心做恶，就罚 ICP 。

当 IC 上的生态越来越繁荣，越来越多的企业、组织在 IC 上部署去中心化应用 Dapp 时，就需要把 ICP 燃烧成 Cycles 交部署应用的费用。

持有 ICP 代币的用户可以把 ICP 质押在 NNS 中，创建 neuron（神经元），然后进行投票，投票之后会收到 ICP 代币奖励，这是 ICP 的通胀机制之一；但 NNS 的作用是投票治理，并不是赚利息。

另外，NNS 会给数据中心提供者发送 ICP 代币奖励，这种另一种通胀机制。

目前 ICP 只有这两种通胀机制。

ICP 代币可以兑换成 Cycles 代币，二者的汇率是动态变化的，以保证 Cycles 价值相对稳定，防止造成客户使用费用大幅增长的情况，这一点比以太坊高明多了。

客户使用 ICP 网络需要用 Cycles 支付，这部分 Cycles 会被燃烧，所以这是 ICP 的通缩机制，目前是唯一的通缩机制。

以上是 ICP 的经济模型介绍。



## Internet Identity


